var V=Object.defineProperty;var M=(a,e,t)=>e in a?V(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var v=(a,e,t)=>M(a,typeof e!="symbol"?e+"":e,t);import{d as h,j as P,B as F,u as $,r as b,w,C as g,o as k,c as N,x as c,V as C,k as T,v as B,D as E,b as J,E as q,f as D,p as R,e as S}from"./tools-AppBase.vue_vue_type_script_setup_true_lang-DxqoVBse.js";const f={symbol:"",exponent:0},d=[{symbol:"Q",exponent:30},{symbol:"R",exponent:27},{symbol:"Y",exponent:24},{symbol:"Z",exponent:21},{symbol:"E",exponent:18},{symbol:"P",exponent:15},{symbol:"T",exponent:12},{symbol:"G",exponent:9},{symbol:"M",exponent:6},{symbol:"k",exponent:3},{symbol:"h",exponent:2},{symbol:"da",exponent:1},f,{symbol:"d",exponent:-1},{symbol:"c",exponent:-2},{symbol:"m",exponent:-3},{symbol:"μ",exponent:-6},{symbol:"u",exponent:-6},{symbol:"n",exponent:-9},{symbol:"p",exponent:-12},{symbol:"f",exponent:-15},{symbol:"a",exponent:-18},{symbol:"z",exponent:-21},{symbol:"y",exponent:-24},{symbol:"r",exponent:-27},{symbol:"q",exponent:-30}],r=class r{constructor(e,t){this.fraction=e,this.prefix=t}get actualValue(){return this.fraction*10**this.prefix.exponent}static getPrefixSymbols(e){return d.filter(t=>t.exponent%(e?1:3)===0).map(t=>t.symbol)}static test(e){return r.siValuePattern.test(e??"")}static parse(e){const t=r.siValuePattern.exec(e??"");if(t==null)return new r(Number.NaN,f);const o=Number.parseFloat(t[1]),n=d.find(s=>s.symbol===t[2]);return n?new r(o,n):new r(o,f)}static fit(e,t){if(!Number.isFinite(e)&&t.length===0)return new r(e,f);if(e!==0){const o=t.map(n=>{const s=r.getPrefix(n),i=e*10**-s.exponent,u=Math.abs(i-500);return{prefix:s,practicalValue:i,rank:u}}).sort((n,s)=>n.rank-s.rank);return new r(o[0].practicalValue,o[0].prefix)}else return new r(0,f)}static fitBy(e,t){if(!Number.isFinite(e))return new r(e,f);const o=r.getPrefix(t),n=e*10**-o.exponent;return new r(n,o)}static getPrefix(e){const t=d.find(o=>o.symbol===e);if(!t)throw new Error(`Prefix symbol '${e}' is not defined.`);return t}static successor(e,t){const o=r.getPrefix(e),n=d.filter(i=>i.exponent>o.exponent&&i.exponent%(t?1:3)===0);if(n.length===0)return e;const s=n.slice(-1)[0];return n.filter(i=>i.exponent===s.exponent)[0].symbol}static predecessor(e,t){const o=r.getPrefix(e),n=d.filter(s=>s.exponent<o.exponent&&s.exponent%(t?1:3)===0);return n.length===0?e:n[0].symbol}};v(r,"siValuePattern",/^([+-]?(?:[0-9]*\.)?[0-9]+)([QRYZEPTGMkmuμnpfazyrq]?)$/);let x=r;const m={required:a=>!!a||"値を入力してください",value:a=>Number.isFinite(x.parse(a).fraction)||"不正な値です",notZero:a=>Number(a)!==0||"値を 0 にはできません",notNegative:a=>{const e=x.parse(a);return Number.isFinite(e.fraction)&&e.fraction>=0||"負値にはできません"}},z=h({__name:"SIValueInput",props:P({unit:null,prefixSymbols:null,fractionDigits:null,rule:null},{value:{},valueModifiers:{}}),emits:["update:value"],setup(a){const e=F(),t=$(a,"value"),o=b(),n=b();w(()=>t.value,()=>{s()}),g(()=>{s()});function s(){var u;if(typeof t.value<"u"&&Number.isFinite(t.value)&&!((u=n.value)!=null&&u.focused)){const l=x.fit(t.value,a.prefixSymbols??[""]);o.value=`${l.fraction.toFixed(a.fractionDigits??3)}${l.prefix.symbol}`}}function i(u){const l=x.parse(u);Number.isFinite(l.fraction)&&(t.value=l.actualValue)}return(u,l)=>(k(),N(c(C),{"model-value":o.value,"onUpdate:modelValue":[l[0]||(l[0]=p=>o.value=p),i],rules:c(e).readonly?[]:a.rule?a.rule:[c(m).required,c(m).value,c(m).notZero,c(m).notNegative],prefix:a.unit,class:"text-align-right",reverse:"",inputmode:"numeric",ref_key:"field",ref:n},null,8,["model-value","rules","prefix"]))}}),G=h({__name:"MathJax",props:T({tag:null,node:{type:Boolean},block:{type:Boolean},overlook:{type:Boolean}},{tag:"span"}),setup(a,{expose:e}){const t=a.tag;"MathJax"in window||console.warn("window.MathJax does not exist. For typesetting, MathJax import is required.");const o=b(),n=b(),s=B(()=>a.block?"div":"span"),i=new MutationObserver(p);async function u(){n.value&&(await q(),l(),await window.MathJax.typesetPromise([n.value]))}function l(){if(!(!o.value||!n.value))if(o.value.children.length===0&&!a.node)a.block?n.value.innerText=`$$ ${o.value.innerText} $$`:n.value.innerText=`\\( ${o.value.innerText} \\)`;else{for(;n.value.lastElementChild;)n.value.removeChild(n.value.lastElementChild);for(const y of o.value.childNodes)n.value.appendChild(y.cloneNode(!0))}}async function p(){a.overlook?n.value&&(window.MathJax.typesetClear([n.value]),l()):await u()}return w(()=>[a.node,a.block,a.overlook],p),g(async()=>{await p(),o.value&&i.observe(o.value,{childList:!0,subtree:!0,characterData:!0})}),E(()=>i.disconnect),e({typeset:u}),(y,Z)=>(k(),N(c(t),null,{default:J(()=>[D("span",{ref_key:"raw",ref:o,class:"mathjax-raw"},[R(y.$slots,"default")],512),S(c(s),{ref_key:"formula",ref:n},null,512)]),_:3}))}});export{m as R,z as _,G as a};
