import{d as v,Y as h,r as i,i as w,w as m,j as x,k,o as y,c as p,b,u,x as g,f as M,m as C,e as T}from"./tools-SIValueInput.vue_vue_type_script_setup_true_lang-ysALgvjn.js";const J=v({__name:"MathJax",props:h({tag:null,node:{type:Boolean},block:{type:Boolean},overlook:{type:Boolean}},{tag:"span"}),setup(a,{expose:c}){const d=a.tag;"MathJax"in window||console.warn("window.MathJax does not exist. For typesetting, MathJax import is required.");const t=i(),e=i(),f=w(()=>a.block?"div":"span"),l=new MutationObserver(n);async function r(){e.value&&(await g(),s(),await window.MathJax.typesetPromise([e.value]))}function s(){if(!(!t.value||!e.value))if(t.value.children.length===0&&!a.node)a.block?e.value.innerText=`$$ ${t.value.innerText} $$`:e.value.innerText=`\\( ${t.value.innerText} \\)`;else{for(;e.value.lastElementChild;)e.value.removeChild(e.value.lastElementChild);for(const o of t.value.childNodes)e.value.appendChild(o.cloneNode(!0))}}async function n(){a.overlook?e.value&&(window.MathJax.typesetClear([e.value]),s()):await r()}return m(()=>[a.node,a.block,a.overlook],n),x(async()=>{await n(),t.value&&l.observe(t.value,{childList:!0,subtree:!0,characterData:!0})}),k(()=>l.disconnect),c({typeset:r}),(o,$)=>(y(),p(u(d),null,{default:b(()=>[M("span",{ref_key:"raw",ref:t,class:"mathjax-raw"},[C(o.$slots,"default")],512),T(u(f),{ref_key:"formula",ref:e},null,512)]),_:3}))}});export{J as _};
